####
基础
####

这一章介绍关于 Haskell 的一些基础知识。

****
注释
****

注释是会被 Haskell 跳过的部分，不会对程序产生影响。只对于代码编写者和阅读者理解代码提供帮助。

.. code:: haskell

   -- 这行代码不会产生任何作用。
   putStrLn "Hello, world!"

注释也可以写在多行中：

.. code:: haskell

   {-
   这部分内容全部都是注释。
   包括这行。
   -}
   putStrLn "Hello, world!"

************
类型与字面量
************

字面量是指不会经过计算，而是正如它实际上内容完全相同的值。比如数字 ``42``，就是代表实际值是四十二的字面量。

在 Haskell 中，每个值都有它自己的类型，作为值的固有属性。

数字
====

Haskell 中有一系列的数字类型，不过主要使用到的数字类型分为两大类，整数与浮点数（精度固定的分数）。

整数类型中，最长用到的是 ``Int`` 这个类型。``42 :: Int`` 就是一个 ``Int`` 类型的字面量。需要注意的是，``Int`` 类型的范围是有限的，并且在不同的 CPU 架构的机器上上的范围是不同的。在 32 位 CPU 架构上它会是一个 32 位的浮点数，在 64 位 CPU 的架构上是一个 64 位的浮点数。虽然 ``Int`` 类型范围有限，但是它的计算速度很快，并且绝大部分情况下使用的数字并不会超过它的范围。

``Integer`` 整数类型没有范围限制，以下值

.. code:: haskell

   10000000000000000000 :: Integer

就是一个 ``Integer`` 类型的字面量。虽然 ``Integer`` 表示范围更大，但是与 ``Int`` 相比，计算机同样大小的值处理起来会慢一些。

常用的浮点数类型也有两种，``Float`` 和 ``Double``，对应的字面量分别是 ``3.14 :: Float`` 和 ``2.71828 :: Double``。不过它们的精度都是有限的，分别对应 32 位浮点数和 64 位浮点数。

以上几种类型的字面量中，事实上 ``::`` 后面的部分是不必要的，并且也不推荐填写。Haskell 会根据一个值的上下文，自动的推断出它的最合适的类型。只有在某些特殊情况，以及强行指定实际值类型的时候才需要填写。

字符与字符串
============

``Char`` 类型代表一个单个的 unicode 字符。它的字面量是用单引号包裹的字符，比如 ``'A'`` 或者 ``'元'``。与各种数字类型不同，它的字面量几乎没有歧义，所以 ``'A' :: Char`` 这种带类型的字面量就更加没有必要了。

``String`` 类型与它的中文惯用翻译名“字符串”所标示的一样，代表一连串的字符。它的字面量用双引号包裹，``"Hello, World"`` 或者 ``"你好世界"`` 都是字符串字面量。

列表
====

列表是 Haskell 中非常重要的一种数据类型，同时它也是一种容器类型。

容器类型的意思是，它像一个箱子一样，可以“装”下其他的类型。一个装字符串的列表，类型表示是 ``[String]``，一个装整形数字类型的列表，类型表示是 ``[Int]``。

实际使用的时候，我们可以这样初始化一个字符串列表：

.. code:: haskell

   ["foo", "bar", "baz"]

需要注意的是，列表中只能装同样类型的数据，所以不能创建一个既有数字又有字符串的列表。不过如果我们在初始化一个列表时，使用了不同的类型的数据，而这些数据又属于同样的类型类（后续会提到类型类的概念），Haskell 的类型推导系统会自动使用最适合它们的类型类作为列表的类型，并且列表所有元素的类型，既为此类型类。

列表有一些常见操作，比如获取列表的长度，以及获取其中某个位置的值。在 Haskell 中，这都是通过函数或者操作符来实现的。

``length`` 函数可以获取列表的长度：

.. code:: haskell

   length ["foo", "bar", "baz"]  -- 输出为 3

``head`` 函数可以获取列表的第一个元素：

.. code:: haskell

   head ["foo", "bar", "baz"] -- 输出为 "foo"

``last`` 函数可以获取列表的最后一个元素：

.. code:: haskell

   last ["foo", "bar", "baz"] -- 输出为 "baz"

``rest`` 函数可以获取列表除了第一个函数以外，包含剩下的所有元素的列表：

.. code:: haskell

   rest ["foo", "bar", "baz"] -- 输出为 ["bar", "baz"]

这时有人会猜到，字符串这一类型，就是一个 ``Char`` 类型的列表，既 ``[Char]``。没有错，事实上 ``String`` 就是这么定义出来的。

元组
====

元组与列表类似，也是一种容器类型，也是用来保存一组数据的类型。

但是它与列表最大的不同是，元组里保存的每个元素，类型可以不相同。于此同时，不同长度的元组，或者对应位置的元素的类型不同的元组，它们是不同的类型。

保存一个字符串和一个整形数字的元组，它的类型是 ``(String, Int)``。保存两个字符串的元组类型是 ``(String, String)``，保存三个字符串的元组类型是 ``(String, String)``。

元组的初始化方法是：

.. code:: haskell

   ("Jim Green", 14)

二元组是只有两个元素的元组，因为它很常见，可以用来实现类似 Lisp 中的 Pair，因此有两个专门针对它的函数：

.. code:: haskell

   fst ("foo", "bar") -- 结果为 "foo"

   snd ("foo", "bar") -- 结果为 "bar"

除此之外，没有任何元素的零元组（``()``）也非常特殊，因为它不包含任何内容，所以很多情况下它的语义都相当于空，类似其他语言的 null 等特殊值。

************
获取类型信息
************

如果是在 REPL 中，可以很轻松的使用 ``:t`` 命令获取某个值的类型信息。

.. code:: 

   Prelude> :t ("Hello", "World")
   ("Hello", "World") :: ([Char], [Char])

****
绑定
****

Haskell 是一门纯函数式编程语言，这也意味着所有的值都是不可变的。如果你学过一些其他的语言，你可能会在找一些类似「变量」、「赋值」的概念。很遗憾，Haskell 中不存在这些概念，唯一类似的，就是「绑定」。

你可以把一个值「绑定」到一个容易记的名称上，后续可以更加方便地使用它：

.. code::

   n = 42
   s = "Hello world!"

一般情况下，不能重新对一个已经存在的名字进行重新绑定。但是在命令行解释器模式下，为了方便这种操作是允许的。

另外绑定还可以限定作用域，我们会在后续章节做详细介绍。